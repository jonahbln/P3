#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
import pandas as pd


class Router:

    # Define the columns and their expected types for an empty DataFrame
    bgp_table = pd.DataFrame({
    'network': pd.Series(dtype='str'),
    'netmask': pd.Series(dtype='str'),
    'peer': pd.Series(dtype='str'),
    'localpref': pd.Series(dtype='int'),
    'ASPath': pd.Series(dtype='object'),  # 'object' allows for lists
    'selfOrigin': pd.Series(dtype='bool'),
    'origin': pd.Series(dtype='str')
    })

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_message(msg)

                print("Received message '%s' from %s" % (msg, srcif))
        return


    def process_message(self, utf8_message):
        try:
        
        # Print the decoded JSON message
            print("Received JSON message:", utf8_message)

        # Convert the JSON string to a hashtable
            message_dict = json.loads(utf8_message)
        
        # Attempt to get the message type
            try:
                message_type = message_dict["type"]
            except KeyError:
                print("Message does not contain a 'type' field.")
                return None

        # Define a mapping of message types to their respective handlers
            switch = {
                "handshake": self.handle_handshake,
                "update": self.handle_update,
                "withdrawal": self.handle_withdrawal,
                "data": self.handle_data,
                "dump": self.handle_dump,
            }

        # Call the corresponding function based on the message type, if it exists
            try:
                # Attempt to get the corresponding handler and execute it
                message_type = message_type.strip().lower()
                print(message_type)
                handler = switch[message_type]
                handler(message_dict)
            except KeyError:
            # Handle unknown message types
                print(f"Unknown message type: {message_type}")

       
        except json.JSONDecodeError as e:
            print(f"Failed to decode JSON: {e}")
            return None


    # Handler methods for each message type:
    def handle_handshake(self, message):
        print("Processing a handshake message:", message)



    def handle_update(self, message):
        print("Processing an update message:", message)
        try:
        # Extract the 'msg' field, which is itself a JSON-like dictionary.
            update_data = message.get('msg')

            # Create a new DataFrame row from the 'msg' data
            new_row = {
                'network': update_data['network'],
                'netmask': update_data['netmask'],
                'peer': self.our_addr(update_data['network']),
                'localpref': update_data['localpref'],
                'ASPath': update_data['ASPath'],
                'selfOrigin': update_data['selfOrigin'],
                'origin': update_data['origin']
            }

        # Append the new row to the BGP table
            self.bgp_table = pd.concat([self.bgp_table, pd.DataFrame([new_row])], ignore_index=True)
            print(f"Added new entry to BGP table: {new_row}")

        except Exception as e:
            print(f"Error processing update message: {e}")
        

    def handle_withdrawal(self, message):
        print("Processing a withdrawal message:", message)

    def handle_data(self, message):
        print("Processing a data message:", message)

        destination_ip = message.get('dst')
        print(len(self.bgp_table))
        
        for index, row in self.bgp_table.iterrows():
            network_ip = row['network']
            netmask = row['netmask']
            print(network_ip)
            print(destination_ip)


            dest_bits = self.ip_to_int(destination_ip)
            network_bits = self.ip_to_int(network_ip)
            netmask_bits = self.ip_to_int(netmask)
            print("network and destination checking:", network_ip, destination_ip)

            if (dest_bits & netmask_bits == network_bits & netmask_bits):
                print("network and destination HIT:", network_ip, destination_ip)
                return network_ip

    def handle_dump(self, message):
        print("Processing a dump message:", message)

        source_ip = message.get('src')

        table_msg = []
        for index, row in self.bgp_table.iterrows():
            table_msg.append({
                'network':row['network'],
                'netmask':row['netmask'],
                'peer':row['peer'],
                'localpref':row['localpref'],
                'ASPath':row['ASPath'],
                'selfOrigin':row['selfOrigin'],
                'origin':row['origin']})

        return_message = {
            'src' : self.our_addr(source_ip),
            'dst' : source_ip,
            'type' : "table",
            'msg' : table_msg
            }
        
        self.send(source_ip, json.dumps(return_message))

    def ip_to_int(self, ip):
        quads = ip.split('.')
        binary_ip = (int(quads[0]) << 24) + (int(quads[1]) << 16) + (int(quads[2]) << 8) + int(quads[3])
        return binary_ip

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
