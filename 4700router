#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
import pandas as pd


class Router:

    # Define the columns and their expected types for an empty DataFrame
    bgp_table = pd.DataFrame({
    'network': pd.Series(dtype='str'),
    'netmask': pd.Series(dtype='str'),
    'peer': pd.Series(dtype='str'),
    'localpref': pd.Series(dtype='int'),
    'ASPath': pd.Series(dtype='object'),  # 'object' allows for lists
    'selfOrigin': pd.Series(dtype='bool'),
    'origin': pd.Series(dtype='str')
    })

    withdrawal_history = []
    update_history = []

    relations = {}
    sockets = {}
    ports = {}
    neighbor_ips = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn 
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.neighbor_ips.append(neighbor)
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        print("In send, sending to network: ", network)
        print("In send, sending message: ", message)

        print("In send, self.sockets[network]: ", self.sockets[network])
        print("In send, self.ports[network]: ", self.ports[network])

        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_message(msg)

                print("Received message '%s' from %s" % (msg, srcif))
        return


    def process_message(self, utf8_message):
        try:
        
        # Print the decoded JSON message
            print("Received JSON message:", utf8_message)

        # Convert the JSON string to a hashtable
            message_dict = json.loads(utf8_message)
        
        # Attempt to get the message type
            try:
                message_type = message_dict['type']
            except KeyError:
                print("Message does not contain a 'type' field.")
                return None

        # Define a mapping of message types to their respective handlers
            switch = {
                'handshake': self.handle_handshake,
                'update': self.handle_update,
                'withdrawal': self.handle_withdrawal,
                'data': self.handle_data,
                'dump': self.handle_dump,
            }

        # Call the corresponding function based on the message type, if it exists
            try:
                # Attempt to get the corresponding handler and execute it
                message_type = message_type.strip().lower()
                handler = switch[message_type]
                handler(message_dict)
            except KeyError:
            # Handle unknown message types
                print(f"Unknown message type: {message_type}")

       
        except json.JSONDecodeError as e:
            print(f"Failed to decode JSON: {e}")
            return None

    # Handler methods for each message type:
    def handle_handshake(self, message):
        print("Processing a handshake message:", message)

    def handle_update(self, message):
        print("Processing an update message:", message)
        self.update_history.append(message)

        update_data = message.get('msg')

            # Create a new DataFrame row from the 'msg' data
            new_row = {
                'network': update_data['network'],
                'netmask': update_data['netmask'],
                'peer': message.get('src'),
                'localref': update_data['localpref'],
                'ASPath': update_data['ASPath'],
                'selfOrigin': update_data['selfOrigin'],
                'origin': update_data['origin']
            }

        # Append the new row to the BGP table
        self.bgp_table = pd.concat([self.bgp_table, pd.DataFrame([new_row])], ignore_index=True)
        print(f"Added new entry to BGP table: {new_row}")


        msg = {
            'netmask' : message['netmask'],
            'network' : message['network'],
            'ASPath' : message['ASPath']
            }
        for neighbor in self.neighbor_ips:
            return_message = {
                'type' : 'update',
                'src' : self.our_addr(neighbor),
                'dst' : neighbor,
                'msg' : msg
                }
            if message['src'] != neighbor:
                if self.relations[message['src']] == "customer":
                    print("Propegating customer's update to peer at: ", neighbor)
                    self.send(neighbor, json.dumps(return_message))
                else:
                    if self.relations[neighbor] == "customer":
                        print("Propegating update to a customer at: ", neighbor)
                        self.send(neighbor, json.dumps(return_message))

    def handle_withdrawal(self, message):
        print("Processing a withdrawal message:", message)
        self.withdrawal_table.append(message) # save a copy of the withdrawal message in case we need it later
        
        for index, row in self.bgp_table.iterrows():
            for i in range(0,len(message['msg'])):
                if(message['src'] == row['peer'] and (row['network'] == message['msg'][i]['network'] and row['netmask'] == message['msg'][i]['netmask'])):
                    self.bgp_table.pop(row)
                    
        for neighbor in self.neighbor_ips:
            if message['src'] != neighbor:
                if self.relations[message['src']] == "customer":
                    print("Propegating customer's withdrawl to peer at: ", neighbor)
                    self.send(neighbor, json.dumps(message))
                else:
                    if self.relations[neighbor] == "customer":
                        print("Propegating withdrawl to customer at: ", neighbor)
                        self.send(neighbor, json.dumps(message))

    def handle_data(self, message):
        print("Processing a data message:", message)

        network_to_send = self.find_destination(message).get('peer')
        self.send(network_to_send, json.dumps(message))


    def find_destination(self, message):
        destination_ip = message.get('dst')
        best_address = None
        best_netmask = None
        best_index = None; 


        for index, row in self.bgp_table.iterrows():
            network_ip = row['network']
            netmask = row['netmask']
            print(network_ip)
            print(destination_ip)


            dest_bits = self.ip_to_int(destination_ip)
            network_bits = self.ip_to_int(network_ip)
            netmask_bits = self.ip_to_int(netmask)
            print("network and destination checking:", network_ip, destination_ip)

            if (dest_bits & netmask_bits == network_bits & netmask_bits):
                print("network and destination HIT:", network_ip, destination_ip)
                if (best_address == None):
                    best_address = network_ip
                    best_netmask = netmask_bits
                    best_index = index; 

                else: 
                    if (self.better_prefix(self.ip_to_int(best_netmask), netmask_bits) == netmask_bits):
                        best_address = network_ip
                        best_netmask = netmask_bits
                        best_index = index; 

        return self.bgp_table.iloc[best_index]
                
    
    def better_prefix(self, netmask1, netmask2):

        posn1 = None
        posn2 = None


        # Iterate from right to left to find the first '1'
        for i, bit in enumerate(reversed(bin(netmask1))):
            if bit == '1':
                posn1 = i 

         # Iterate from right to left to find the first '1'
        for i, bit in enumerate(reversed(bin(netmask2))):
            if bit == '1':
                posn2 = i 

        if (posn1 < posn2):
            return netmask1
        else:
            return netmask2

    
      

    def handle_dump(self, message):
        print("Processing a dump message:", message)

        source_ip = message.get('src')

        table_msg = []
        for index, row in self.bgp_table.iterrows():
            table_msg.append({
                'network':row['network'],
                'netmask':row['netmask'],
                'peer':row['peer'],
                'localpref':row['localpref'],
                'ASPath':row['ASPath'],
                'selfOrigin':row['selfOrigin'],
                'origin':row['origin']})

        return_message = {
            'src' : self.our_addr(source_ip),
            'dst' : source_ip,
            'type' : 'table',
            'msg' : table_msg
            }
        
        self.send(source_ip, json.dumps(return_message))

    def ip_to_int(self, ip):
        quads = ip.split('.')
        binary_ip = (int(quads[0]) << 24) + (int(quads[1]) << 16) + (int(quads[2]) << 8) + int(quads[3])
        return binary_ip

    def int_to_ip(self, binary_ip):
        quads = [
            (binary_ip >> 24) & 0xFF,
            (binary_ip >> 16) & 0xFF,
            (binary_ip >> 8) & 0xFF,
            binary_ip & 0xFF ]
        
        ip = '.'.join(map(str, quads))
        return ip

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()