#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
import pandas as pd


class Router:

    # define the columns and their expected types for an empty DataFrame to act as our routing table
    bgp_table = pd.DataFrame({
    'network': pd.Series(dtype='str'),
    'netmask': pd.Series(dtype='str'),
    'peer': pd.Series(dtype='str'),
    'localpref': pd.Series(dtype='int'),
    'ASPath': pd.Series(dtype='object'),  # 'object' allows for lists
    'selfOrigin': pd.Series(dtype='bool'),
    'origin': pd.Series(dtype='str')
    })

    # lists to keep a history of announcements which come in handy if rebuilding the routing table
    withdrawal_history = []
    update_history = []

    # a list of ips of each neighbor we are directly connected to
    neighbor_ips = []

    relations = {}
    sockets = {}
    ports = {}

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn 
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.neighbor_ips.append(neighbor)
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_message(msg, srcif)
        return

    # takes in a message from a neighbor, and uses the associated handler to process the message
    def process_message(self, utf8_message, neighbor_src):
        try:
        # Convert the JSON string to a hashtable
            message_dict = json.loads(utf8_message)
        
        # Attempt to get the message type
            try:
                message_type = message_dict['type']
            except KeyError:
                print("Message does not contain a 'type' field.")
                return None

            # match the message type with the proper handler function
            match message_type:
                case 'update':
                    self.handle_update(message_dict, True)
                case 'withdraw':
                    self.handle_withdrawal(message_dict, True)
                case 'data':
                    self.handle_data(message_dict, neighbor_src)
                case 'dump':
                    self.handle_dump(message_dict)
                case _:
                    print(f"Unknown message type: {message_type}")
       
        except json.JSONDecodeError as e:
            print(f"Failed to decode JSON: {e}")
            return None

    # takes in an update announcemnet, and adds it to our routing table, then propegates it to neighbors, dpeending on peer relations
    def handle_update(self, message, from_neighbor):
        if from_neighbor:
            self.update_history.append(message)

        update_data = message.get('msg')

            # Create a new DataFrame row from the 'msg' data
        new_row = {
            'network': update_data['network'],
            'netmask': update_data['netmask'],
            'peer': message.get('src'),
            'localpref': update_data['localpref'],
            'ASPath': update_data['ASPath'],
            'selfOrigin': update_data['selfOrigin'],
            'origin': update_data['origin']
        }

        # Append the new row to the BGP table
        self.bgp_table = pd.concat([self.bgp_table, pd.DataFrame([new_row])], ignore_index=True)

        # from_neighbor is false only when we are rebuilding the routing table, 
        # we wouldnt want to send any announcements in this case
        if from_neighbor:
            ASPath = update_data['ASPath'].copy()
            ASPath.insert(0, self.asn)
            msg = {
                'netmask' : update_data['netmask'],
                'network' : update_data['network'],
                'ASPath' : ASPath
                }
            for neighbor in self.neighbor_ips: 
                return_message = {
                    'type' : 'update',
                    'src' : self.our_addr(neighbor),
                    'dst' : neighbor,
                    'msg' : msg
                    }
                # check the relationship with each neighbor, sending the update along if necessary
                if message['src'] != neighbor:
                    if self.relations[message['src']] == "cust":
                        self.send(neighbor, json.dumps(return_message))
                    else:
                        if self.relations[neighbor] == "cust":
                            self.send(neighbor, json.dumps(return_message))

            self.aggregate()

    # perform aggregation on our existing routing table after each update
    def aggregate(self):
        # sort our table by network and netmask
        self.bgp_table = self.bgp_table.sort_values(by=['network', 'netmask'], ascending=[True, False])
        self.bgp_table = self.bgp_table.reset_index(drop=True)
        i = 0
        while i < len(self.bgp_table) - 1:
            current = self.bgp_table.iloc[i]
            next_entry = self.bgp_table.iloc[i + 1]

            # check if the two routes have adjacent address spaces and the same attributes
            adjacent = self.is_adjacent(current, next_entry)
            same_attr = self.same_attributes(current, next_entry)
            if(adjacent and same_attr):
                # if so, combine them into one entry
                combined_entry = self.combine_networks(current, next_entry)
                self.bgp_table.iloc[i] = combined_entry
                self.bgp_table = self.bgp_table.drop(self.bgp_table.index[i + 1]).reset_index(drop=True)
                self.bgp_table = self.bgp_table.reset_index(drop=True)
                i = 0
            else:
                i = i+1

    # helper function for combining route entries
    def combine_networks(self, entry1, entry2):
        network1Int = self.ip_to_int(entry1['network'])
        network2Int = self.ip_to_int(entry2['network'])
    
        startNetwork = min(network1Int, network2Int)
        endNetwork = max(network1Int, network2Int) + (2 ** (32 - self.netmask_to_prefix_length(entry2['netmask']))) - 1
    
        address_range = endNetwork - startNetwork + 1

        new_prefix_length = 32
        while (2 ** (32 - new_prefix_length)) < address_range:
            new_prefix_length -= 1

        new_netmask = self.prefix_length_to_netmask(new_prefix_length)

        return {
            'network': self.int_to_ip(startNetwork),  
            'netmask': new_netmask,
            'ASPath': entry1['ASPath'],  
            'localpref': entry1['localpref'],
            'peer': entry1['peer'],
            'origin': entry1['origin'],
            'selfOrigin': entry1['selfOrigin'],
        }
    
    # helper function to convert a prefix length back to its whole netmask as a string
    def prefix_length_to_netmask(self, prefix_length):
        binary_netmask = ('1' * prefix_length).ljust(32, '0')
        netmask = [str(int(binary_netmask[i:i+8], 2)) for i in range(0, 32, 8)]
        return '.'.join(netmask)

    # helper function to check if two routes are in adjacent addressing spaces
    def is_adjacent(self, entry1, entry2):
        # Convert network addresses to integers
        network1Int = self.ip_to_int(entry1['network'])
        network2Int = self.ip_to_int(entry2['network'])
    
        # Convert netmask strings to prefix lengths
        prefixLength1 = self.netmask_to_prefix_length(entry1['netmask'])
        prefixLength2 = self.netmask_to_prefix_length(entry2['netmask'])
    
        smallerPrefix = min(prefixLength1, prefixLength2)
    
        # Calculate the network block size based on the smaller prefix length
        block_size = 2 ** (32 - smallerPrefix)
        network1End = network1Int + block_size - 1
    
        return (network2Int == (network1Int + block_size)) or (network1Int <= network2Int <= network1End)

    # helper function to convert a netmask to its prefix length
    def netmask_to_prefix_length(self, netmask):
        binary_str = ''.join(f"{int(octet):08b}" for octet in netmask.split('.'))
        return binary_str.count('1')

    # helper function to check if two routes have the same attributes, are able to be merged
    def same_attributes(self, entry1, entry2):
        # Compare next-hop and other attributes
        return (entry1['peer'] == entry2['peer'] and
                entry1['localpref'] == entry2['localpref'] and
                entry1['selfOrigin'] == entry2['selfOrigin'] and 
                entry1['origin'] == entry2['origin'] and 
                entry1['ASPath'] == entry2['ASPath'] and
                self.netmask_to_prefix_length(entry1['netmask']) == self.netmask_to_prefix_length(entry2['netmask']))

    # handle withdrwa announcments, removing affected routes from our table, and deaggregating as needed
    def handle_withdrawal(self, message, from_neighbor):
        if from_neighbor:
            self.withdrawal_history.append(message) 
        
        for index, row in self.bgp_table.iterrows():
            for i in range(0,len(message['msg'])): #check if the announcment pertains to any of our routes, and drop it if so
                if(message['src'] == row['peer'] and (row['network'] == message['msg'][i]['network'] and row['netmask'] == message['msg'][i]['netmask'])):
                    self.bgp_table.drop(index, inplace=True)
                    self.bgp_table.reset_index(drop=True, inplace=True)
                    
        # from_neighbor is false only when we are rebuilding the routing table, 
        # we wouldnt want to send any announcements in this case
        if from_neighbor:
            for neighbor in self.neighbor_ips:
                if message['src'] != neighbor:
                    if self.relations[message['src']] == "cust": #check the peer relations, and send message along if necessary
                        message2 = {
                            'src':self.our_addr(neighbor),
                            'dst':neighbor,
                            'type':'withdraw',
                            'msg':message['msg']
                        }
                        self.send(neighbor, json.dumps(message2))
                    else:
                        if self.relations[neighbor] == "cust":
                            message2 = {
                            'src':self.our_addr(neighbor),
                            'dst':neighbor,
                            'type':'withdraw',
                            'msg':message['msg']
                            }
                            self.send(neighbor, json.dumps(message2))
            self.disaggregate()

    # rebuild the routing table from all of our stored announcments, and then aggregate from there
    def disaggregate(self):
        self.bgp_table = pd.DataFrame(columns=self.bgp_table.columns)
        for msg in self.update_history:
            self.handle_update(msg, False)
        for msg in self.withdrawal_history:
            self.handle_withdrawal(msg, False)   
        self.aggregate()

    # take in a data message, and find the best route, sending out the data message if such route exists and is legal
    def handle_data(self, message, neighbor_src):
        network_to_send = self.find_destination(message)

        no_route_message = {
                "src":  self.our_addr(message['src']),
                "dst":  message['src'],
                "type": "no route",
                "msg":  {}
            }
        if (network_to_send == -1): # if there is no route in the routing table for this data message, send no route
            self.send(neighbor_src, json.dumps(no_route_message))

        elif ((self.relations[neighbor_src] == 'peer' or self.relations[neighbor_src] == 'prov') and
            (self.relations[self.bgp_table.iloc[network_to_send].get('peer')] == 'prov' 
            or self.relations[self.bgp_table.iloc[network_to_send].get('peer')] == 'peer')):
            # if the peer/prov relationship would be unprofitable, send no route
            self.send(neighbor_src, json.dumps(no_route_message))

        else: # send the data
            self.send(self.bgp_table.iloc[network_to_send].get('peer'), json.dumps(message))

    # helper function to find the destination of a given DATA message
    def find_destination(self, message):
        destination_ip = message.get('dst')
        best_index = None 
        best_row = None

        # for each entry in the routing table
        for index, row in self.bgp_table.iterrows():
            network_ip = row['network']
            netmask = row['netmask']

            dest_bits = self.ip_to_int(destination_ip)
            network_bits = self.ip_to_int(network_ip)
            netmask_bits = self.ip_to_int(netmask)

            # compare to the data message, checking each of the scenarios as a hierarchy
            if (dest_bits & netmask_bits == network_bits & netmask_bits):
                if (best_index == None):
                    best_index = index 
                    best_row = row
                
                elif (netmask_bits == self.ip_to_int(best_row.netmask)):
                    if (row.localpref > best_row.localpref):
                        best_row = row
                        best_index = index
                    elif (row.localpref == best_row.localpref):

                        if (row.selfOrigin and not best_row.selfOrigin):
                            best_row = row
                            best_index = index
                        elif (row.selfOrigin == best_row.selfOrigin):
                            if(len(row.ASPath) < len(best_row.ASPath)):
                                best_row = row
                                best_index = index
                            elif (len(row.ASPath) == len(best_row.ASPath)):
                                originScore = self.checkOrigin(row.origin, best_row.origin)
                                if (originScore == 1):
                                    best_row = row
                                    best_index = index
                                elif (originScore == 0):
                                    bestRowPeer = self.ip_to_int(best_row.peer) 
                                    rowPeer = self.ip_to_int(row.peer) 
                                    if (rowPeer < bestRowPeer):
                                        best_row = row
                                        best_index = index

                elif (self.better_prefix(self.ip_to_int(best_row.netmask), netmask_bits) == netmask_bits):
                    best_index = index
                    best_row = row

        if (best_index == None):
            return -1


        return best_index

    # Return 1 if origin 1 is better, 2 if origin 2 is better, and 0 if they are the same    
    def checkOrigin(self, origin1, origin2):
        score1 = None
        score2 = None

        if (origin1 == "IGP"):
            score1 = 3
        if (origin1 == "EGP"):
            score1 = 2
        if (origin1 == "UNK"):
            score1 = 1

        if (origin2 == "IGP"):
            score2 = 3
        if (origin2 == "EGP"):
            score2 = 2
        if (origin2 == "UNK"):
            score2 = 1

        if (score1 == score2):
            return 0
        if (score1 > score2):
            return 1
        if (score2 > score1):
            return 2
        
    # helper functoin to return the better of two netmasks when looking for a route
    def better_prefix(self, netmask1, netmask2):
        posn1 = None
        posn2 = None

        # Iterate from right to left to find the first '1'
        for i, bit in enumerate(reversed(bin(netmask1))):
            if bit == '1':
                posn1 = i
                break

         # Iterate from right to left to find the first '1'
        for i, bit in enumerate(reversed(bin(netmask2))):
            if bit == '1':
                posn2 = i
                break 

        if (posn1 is None and posn2 is not None):
            return netmask2

        if (posn2 is None and posn1 is not None):
            return netmask1

        if (posn1 < posn2):
            return netmask1
        else:
            return netmask2

    # take in a dump message, and reply with sending our routing table
    def handle_dump(self, message):
        source_ip = message.get('src')

        table_msg = []
        for index, row in self.bgp_table.iterrows():
            table_msg.append({
                'network':row['network'],
                'netmask':row['netmask'],
                'peer':row['peer'],
                'localpref':row['localpref'],
                'ASPath':row['ASPath'],
                'selfOrigin':row['selfOrigin'],
                'origin':row['origin']})

        return_message = {
            'src' : self.our_addr(source_ip),
            'dst' : source_ip,
            'type' : 'table',
            'msg' : table_msg
            }
        
        self.send(source_ip, json.dumps(return_message))

    # convert an string ip to binary
    def ip_to_int(self, ip):
        quads = ip.split('.')
        binary_ip = (int(quads[0]) << 24) + (int(quads[1]) << 16) + (int(quads[2]) << 8) + int(quads[3])
        return binary_ip

    # convert a binary ip to a string
    def int_to_ip(self, binary_ip):
        quads = [
            (binary_ip >> 24) & 0xFF,
            (binary_ip >> 16) & 0xFF,
            (binary_ip >> 8) & 0xFF,
            binary_ip & 0xFF ]
        
        ip = '.'.join(map(str, quads))
        return ip

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()