#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
import pandas as pd


class Router:

    # Define the columns and their expected types for an empty DataFrame
    bgp_table = pd.DataFrame({
    'network': pd.Series(dtype='str'),
    'netmask': pd.Series(dtype='str'),
    'peer': pd.Series(dtype='str'),
    'localpref': pd.Series(dtype='int'),
    'ASPath': pd.Series(dtype='object'),  # 'object' allows for lists
    'selfOrigin': pd.Series(dtype='bool'),
    'origin': pd.Series(dtype='str')
    })

    withdrawal_history = []
    update_history = []

    relations = {}
    sockets = {}
    ports = {}
    neighbor_ips = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn 
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.neighbor_ips.append(neighbor)
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        # print("In send, sending to network: ", network)
        # print("In send, sending message: ", message)

        # print("In send, self.sockets[network]: ", self.sockets[network])
        # print("In send, self.ports[network]: ", self.ports[network])

        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                self.process_message(msg, srcif)

                print("Received message '%s' from %s" % (msg, srcif))
        return


    def process_message(self, utf8_message, neighbor_src):
        try:
        
        # Print the decoded JSON message
            # print("Received JSON message:", utf8_message)

        # Convert the JSON string to a hashtable
            message_dict = json.loads(utf8_message)
        
        # Attempt to get the message type
            try:
                message_type = message_dict['type']
            except KeyError:
                print("Message does not contain a 'type' field.")
                return None

        # # Define a mapping of message types to their respective handlers
        #     switch = {
        #         'handshake': self.handle_handshake,
        #         'update': self.handle_update,
        #         'withdrawal': self.handle_withdrawal,
        #         'data': self.handle_data,
        #         'dump': self.handle_dump,
        #     }

            match message_type:
                case 'handshake':
                    self.handle_handshake(message_dict)
                case 'update':
                    self.handle_update(message_dict)
                case 'withdraw':
                    self.handle_withdrawal(message_dict)
                case 'data':
                    self.handle_data(message_dict, neighbor_src)
                case 'dump':
                    self.handle_dump(message_dict)
                case _:
                    print(f"Unknown message type: {message_type}")

        # # Call the corresponding function based on the message type, if it exists
        #     try:
        #         # Attempt to get the corresponding handler and execute it
        #         message_type = message_type.strip().lower()
        #         handler = switch[message_type]
        #         handler(message_dict)
        #     except KeyError:
        #     # Handle unknown message types
        #         print(f"Unknown message type: {message_type}")

       
        except json.JSONDecodeError as e:
            print(f"Failed to decode JSON: {e}")
            return None

    # Handler methods for each message type:
    def handle_handshake(self, message):
        print("Processing a handshake message:", message)

    def handle_update(self, message):
        print("Processing an update message:", message)
        self.update_history.append(message)

        update_data = message.get('msg')

            # Create a new DataFrame row from the 'msg' data
        new_row = {
            'network': update_data['network'],
            'netmask': update_data['netmask'],
            'peer': message.get('src'),
            'localpref': update_data['localpref'],
            'ASPath': update_data['ASPath'],
            'selfOrigin': update_data['selfOrigin'],
            'origin': update_data['origin']
        }

        # Append the new row to the BGP table
        self.bgp_table = pd.concat([self.bgp_table, pd.DataFrame([new_row])], ignore_index=True)
        # print(f"Added new entry to BGP table: {new_row}")

        ASPath = update_data['ASPath'].copy()
        ASPath.insert(0, self.asn)
        msg = {
            'netmask' : update_data['netmask'],
            'network' : update_data['network'],
            'ASPath' : ASPath
            }
        for neighbor in self.neighbor_ips:
            return_message = {
                'type' : 'update',
                'src' : self.our_addr(neighbor),
                'dst' : neighbor,
                'msg' : msg
                }
            # print("Message source: " + message['src'] + " with relationship: " + self.relations[message['src']])
            if message['src'] != neighbor:
                if self.relations[message['src']] == "cust":
                    # print("Propegating customer's update to peer at: ", neighbor)
                    self.send(neighbor, json.dumps(return_message))
                else:
                    if self.relations[neighbor] == "cust":
                        # print("Propegating update to a customer at: ", neighbor)
                        self.send(neighbor, json.dumps(return_message))
        
        self.aggregate()



    def aggregate(self):
        self.bgp_table = self.bgp_table.sort_values(by=['network', 'netmask'], ascending=[True, False])
        self.bgp_table = self.bgp_table.reset_index(drop=True)
        print("BGP Table Length: ", len(self.bgp_table))
        i = 0
        while i < len(self.bgp_table) - 1:
            current = self.bgp_table.iloc[i]
            next_entry = self.bgp_table.iloc[i + 1]
            print(f"Dumping current row: {current}")
            adjacent = self.is_adjacent(current, next_entry)
            same_attr = self.same_attributes(current, next_entry)

            print("Are Numerically Adjacent?: ", adjacent)
            print("Same Attributes?: ", same_attr)


            if(adjacent and same_attr):
                combined_entry = self.combine_networks(current, next_entry)
                self.bgp_table.iloc[i] = combined_entry
                self.bgp_table = self.bgp_table.drop(self.bgp_table.index[i + 1]).reset_index(drop=True)
                self.bgp_table = self.bgp_table.reset_index(drop=True)
                i = 0
            else:
                i = i+1

    def combine_networks(self, entry1, entry2):
        network1Int = self.ip_to_int(entry1['network'])
        network2Int = self.ip_to_int(entry2['network'])
    
        startNetwork = min(network1Int, network2Int)
        endNetwork = max(network1Int, network2Int) + (2 ** (32 - self.netmask_to_prefix_length(entry2['netmask']))) - 1
    
        address_range = endNetwork - startNetwork + 1

        new_prefix_length = 32
        while (2 ** (32 - new_prefix_length)) < address_range:
            new_prefix_length -= 1

        new_netmask = self.prefix_length_to_netmask(new_prefix_length)

        return {
            'network': self.int_to_ip(startNetwork),  
            'netmask': new_netmask,
            'ASPath': entry1['ASPath'],  
            'localpref': entry1['localpref'],
            'peer': entry1['peer'],
            'origin': entry1['origin'],
            'selfOrigin': entry1['selfOrigin'],
        }
    

    def prefix_length_to_netmask(self, prefix_length):
        binary_netmask = ('1' * prefix_length).ljust(32, '0')
        netmask = [str(int(binary_netmask[i:i+8], 2)) for i in range(0, 32, 8)]
        return '.'.join(netmask)


    def is_adjacent(self, entry1, entry2):
        print("Checking Network 1: " + entry1['network'] + " With Netmask: " + entry1['netmask'])
        print("Against Network 2: " + entry2['network'] + " With Netmask: " + entry2['netmask'])

        # Convert network addresses to integers
        network1Int = self.ip_to_int(entry1['network'])
        network2Int = self.ip_to_int(entry2['network'])
    
        # Convert netmask strings to prefix lengths
        prefixLength1 = self.netmask_to_prefix_length(entry1['netmask'])
        prefixLength2 = self.netmask_to_prefix_length(entry2['netmask'])
    
        smallerPrefix = min(prefixLength1, prefixLength2)
    
        # Calculate the network block size based on the smaller prefix length
        block_size = 2 ** (32 - smallerPrefix)
        network1End = network1Int + block_size - 1

        print("Final Calculations. Network1 int: ", network1Int)
        print("Final Calculations. Block size: ", block_size)
        print("Final Calculations. Network1 end: ", network1End)
        print("Final Calculations. Network2 int: ", network2Int)
    
        return network2Int == network1Int + block_size or network1Int <= network2Int <= network1End


    def netmask_to_prefix_length(self, netmask):
        binary_str = ''.join(f"{int(octet):08b}" for octet in netmask.split('.'))
        return binary_str.count('1')

    def same_attributes(self, entry1, entry2):
        # Compare next-hop and other attributes
        return (entry1['peer'] == entry2['peer'] and
                entry1['localpref'] == entry2['localpref'] and
                entry1['selfOrigin'] == entry2['selfOrigin'] and 
                entry1['origin'] == entry2['origin'] and 
                entry1['ASPath'] == entry2['ASPath'])
    

    def handle_withdrawal(self, message):
        print("Processing a withdrawal message:", message)
        self.withdrawal_history.append(message) 
        
        for index, row in self.bgp_table.iterrows():
            for i in range(0,len(message['msg'])):
                if(message['src'] == row['peer'] and (row['network'] == message['msg'][i]['network'] and row['netmask'] == message['msg'][i]['netmask'])):
                    self.bgp_table.drop(index, inplace=True)
                    self.bgp_table.reset_index(drop=True, inplace=True)
                    
        print("withdraw message with source: " + message['src'] + " and relation: " + self.relations[message['src']])
        for neighbor in self.neighbor_ips:
            if message['src'] != neighbor:
                if self.relations[message['src']] == "cust":
                    message2 = {
                        'src':self.our_addr(neighbor),
                        'dst':neighbor,
                        'type':'withdraw',
                        'msg':message['msg']
                    }
                    print("Propegating customer's withdrawl to peer at: ", neighbor)
                    self.send(neighbor, json.dumps(message2))
                else:
                    if self.relations[neighbor] == "cust":
                        message2 = {
                        'src':self.our_addr(neighbor),
                        'dst':neighbor,
                        'type':'withdraw',
                        'msg':message['msg']
                        }
                        print("Propegating withdrawl to customer at: ", neighbor)
                        self.send(neighbor, json.dumps(message2))

    def handle_data(self, message, neighbor_src):
        print("Processing a data message:", message)

        # for index, row in self.bgp_table.iterrows():
        #     print(f"Dumping BGP row: {row}")

        network_to_send = self.find_destination(message)
        print("Network to send:", network_to_send)
        print("Network source: " + message['src'])
        
        if (network_to_send == -1) or (self.relations[neighbor_src] == 'peer' or self.relations[neighbor_src] == 'provider') and (self.relations[network_to_send] == 'provider' or self.relations[network_to_send] == 'peer'):
            return_message = {
                "src":  self.our_addr(message['src']),        # Example: 172.65.0.1, i.e., the router's IP on the given port
                "dst":  message['src'],   # Example: 134.0.88.77
                "type": "no route",
                "msg":  {}
            }
            self.send(neighbor_src, json.dumps(return_message))
        else:   
            self.send(self.bgp_table.iloc[network_to_send].get('peer'), json.dumps(message))


    def find_destination(self, message):
        destination_ip = message.get('dst')
        best_index = None 
        best_row = None


        for index, row in self.bgp_table.iterrows():
            network_ip = row['network']
            netmask = row['netmask']
            # print(network_ip)
            # print(destination_ip)


            dest_bits = self.ip_to_int(destination_ip)
            network_bits = self.ip_to_int(network_ip)
            netmask_bits = self.ip_to_int(netmask)
            # print("network and destination checking:", network_ip, destination_ip)

            if (dest_bits & netmask_bits == network_bits & netmask_bits):
                # print("network and destination HIT:", network_ip, destination_ip)
                if (best_index == None):
                    best_index = index 
                    best_row = row

                 
                elif (netmask_bits == self.ip_to_int(best_row.netmask)):
                    # print("Netmasks are the same")
                    # print(row.localpref)
                    if (row.localpref > best_row.localpref):
                        best_row = row
                        best_index = index
                    elif (row.localpref == best_row.localpref):
                        # print("Local Prefs are the same") 
                        # print(f"Dumping Best row: {best_row}")
                        # print(f"Dumping row: {row}")

                        if (row.selfOrigin and not best_row.selfOrigin):
                            # print("Better selfOriginfound") 
                            best_row = row
                            best_index = index
                        elif (row.selfOrigin == best_row.selfOrigin):
                            if(len(row.ASPath) < len(best_row.ASPath)):
                                best_row = row
                                best_index = index
                            elif (len(row.ASPath) == len(best_row.ASPath)):
                                # print("Row origin: ", row.origin)
                                # print("BestRow origin: ", best_row.origin)
                                originScore = self.checkOrigin(row.origin, best_row.origin)
                                if (originScore == 1):
                                    best_row = row
                                    best_index = index
                                elif (originScore == 0):
                                    bestRowPeer = self.ip_to_int(best_row.peer) 
                                    rowPeer = self.ip_to_int(row.peer) 
                                    # print("Best Row Peer Addr: ", best_row.peer)
                                    # print("Row Peer Addr: ", row.peer)
                                    # print("Best Row Peer: ", bestRowPeer)
                                    # print("Row Peer: ", rowPeer)
                                    if (rowPeer < bestRowPeer):
                                        # print("rowPeer Number is less")
                                        best_row = row
                                        best_index = index

                elif (self.better_prefix(self.ip_to_int(best_row.netmask), netmask_bits) == netmask_bits):
                    best_index = index
                    best_row = row

        if (best_index == None):
            return -1

        print("PRINTING BEST INDEX: ", best_index)
        return best_index

    # Return 1 if origin 1 is better, 2 if origin 2 is better, and 0 if they are the same    
    def checkOrigin(self, origin1, origin2):
        score1 = None
        score2 = None

        if (origin1 == "IGP"):
            score1 = 3
        if (origin1 == "EGP"):
            score1 = 2
        if (origin1 == "UNK"):
            score1 = 1

        if (origin2 == "IGP"):
            score2 = 3
        if (origin2 == "EGP"):
            score2 = 2
        if (origin2 == "UNK"):
            score2 = 1

        if (score1 == score2):
            return 0
        if (score1 > score2):
            return 1
        if (score2 > score1):
            return 2
        

    def better_prefix(self, netmask1, netmask2):

        posn1 = None
        posn2 = None

        # Iterate from right to left to find the first '1'
        for i, bit in enumerate(reversed(bin(netmask1))):
            if bit == '1':
                posn1 = i
                break

         # Iterate from right to left to find the first '1'
        for i, bit in enumerate(reversed(bin(netmask2))):
            if bit == '1':
                posn2 = i
                break 

        if (posn1 is None and posn2 is not None):
            return netmask2

        if (posn2 is None and posn1 is not None):
            return netmask1

        if (posn1 < posn2):
            return netmask1
        else:
            return netmask2

    
      

    def handle_dump(self, message):
        print("Processing a dump message:", message)

        source_ip = message.get('src')

        table_msg = []
        for index, row in self.bgp_table.iterrows():
            # print(f"Dumping BGP row: {row}")
            table_msg.append({
                'network':row['network'],
                'netmask':row['netmask'],
                'peer':row['peer'],
                'localpref':row['localpref'],
                'ASPath':row['ASPath'],
                'selfOrigin':row['selfOrigin'],
                'origin':row['origin']})

        return_message = {
            'src' : self.our_addr(source_ip),
            'dst' : source_ip,
            'type' : 'table',
            'msg' : table_msg
            }
        
        self.send(source_ip, json.dumps(return_message))

    def ip_to_int(self, ip):
        # print("In IP to int")
        # print(ip)
        # print("\n")

        quads = ip.split('.')
        binary_ip = (int(quads[0]) << 24) + (int(quads[1]) << 16) + (int(quads[2]) << 8) + int(quads[3])
        return binary_ip

    def int_to_ip(self, binary_ip):
        quads = [
            (binary_ip >> 24) & 0xFF,
            (binary_ip >> 16) & 0xFF,
            (binary_ip >> 8) & 0xFF,
            binary_ip & 0xFF ]
        
        ip = '.'.join(map(str, quads))
        return ip

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()